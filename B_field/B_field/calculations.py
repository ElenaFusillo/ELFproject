import math
import cmath
import numpy as np


#Recall all the constants needed in the program
PI = math.pi
MU_ZERO = 1.25663706212 * 10**(-6)


def calc_B_phasors(I, xp, yp, ph_n_deg, xn, yn):

    """calc_B_phasors(I, xp, yp, ph_n_deg, xn, yn) -> B_phasors_n

    It calculates the phasors of the x and y components of the
    magnetic induction field B in a given point for a given cable.

    Given the input, the function rectifies the current phase
    extracting respectively the real and imaginary part of it.
    Then, both real and imaginary part of x and y components are
    multiplied by a transfer function (dependent on the spatial
    disposition of the cable in respect to the point of interest)
    resulting in the magnetic inductin B phasor components of a
    single cable.
    -------------------
    Parameters
    -------------------
    I : int
        Current (A) circulating inside the considered power line
        (composed of a triad of cables)
    xp, yp : float
        Abscissa and ordinate of the point of interest where the
        magnetic induction field B will be calculated at last
    ph_n_deg : float
        Current phase belonging to the n-th cable under consideration
    xn, yn : float
        Abscissa and ordinate of the n-th cable under consideration
    -------------------
    Returns
    -------------------
    B_phasors_n : numpy matrix 2x2
        Respectively the real and imaginary part (columns) of the
        x and y components (rows) of the magnetic induction field B
        produced by a single cable in a given point
    -------------------
    Notes
    -------------------
    The current function implements the calculations present both in
    [1]_"Norma Italiana CEI 106-11" formulas (5) and [2]_"Norma Italiana
    CEI 211-4" formulas (16), which are of the form:

    .. math:: B_{x} = \frac{\mu_{0}}{2\pi} \sum_{i}I_{i} \left[ \frac{y_{i} - y_{p}}
    { \left( x_{p} - x_{i} \right)^{2} + \left(y_{p} - y_{i} \right)^{2} } \right]\\
    B_{y} = \frac{\mu_{0}}{2\pi} \sum_{i}I_{i} \left[ \frac{x_{p} - x_{i}}
    { \left( x_{p} - x_{i} \right)^{2} + \left(y_{p} - y_{i} \right)^{2} } \right]\\
    B_{z} = 0

    TODO vedere se le formule veramente vengono renderizzate, altrimenti inserire immagini?
    -------------------
    References
    -------------------
    ..[1] Norma Italiana CEI 106-11, "Guide for the determination of
    the respect widths for power lines and substations according to
    DPCM 8 July 2003 (Clause 6) - Part 1: Overhead lines and cables",
    first edition, 2006-02.
    ..[2] Norma Italiana CEI 211-4, "Guide to calculation methods of
    electric and magnetic fields generated by power-lines and electrical
    substations", second edition, 2008-09.
    """

    ph_n_rad = math.radians(ph_n_deg)
    I_complex = cmath.rect(I, ph_n_rad)
    I_components = np.array([I_complex.real, I_complex.imag])
    coef = (MU_ZERO / (2*PI)) / ((xp - xn)**2 + (yp - yn)**2)
    transfer_fn_n = np.array([(yn - yp) * coef, (xp - xn) * coef]).reshape(2,1)
    B_phasors_n = I_components * transfer_fn_n
    return B_phasors_n


def calc_B_effective(*B_phasors):

    """calc_B_effective(*B_phasors) -> B_effective

    It calculates the effective value of the magnetic induction field B
    (microTesla) in a given point, considering all the cables provided.

    Firstly, the function computes the resulting real and imaginary
    components of the x and y magnetic induction field B considering
    all the contributes given as input.
    Secondly, 


    TODO descrizione pi√π prolissa dell'algoritmo - controllare la logica

    -------------------
    Parameters
    -------------------
    *B_phasors : numpy matrix 2x2
        Respectively the real and imaginary part (columns) of the
        x and y components (rows) of the magnetic induction field B
        produced by a single cable in a given point
    -------------------
    Returns
    -------------------
    B_effective : float
        Effective magnetic induction field B calculated in the given point
    -------------------
    Notes
    -------------------
    TODO scrivere qualche formula per questa parte qui, con i riferimenti [1][2]
    TODO vedere se anche qui le formule si vedono bene + creare le immagini
    -------------------
    References
    -------------------
    ..[1] Norma Italiana CEI 106-11, "Guide for the determination of
    the respect widths for power lines and substations according to
    DPCM 8 July 2003 (Clause 6) - Part 1: Overhead lines and cables",
    first edition, 2006-02.
    ..[2] Norma Italiana CEI 211-4, "Guide to calculation methods of
    electric and magnetic fields generated by power-lines and electrical
    substations", second edition, 2008-09.
    """

    B_component = 0
    for B_phasor in B_phasors:
        B_component += B_phasor
    sum_B_component = np.sum(B_component**2)
    B_effective = math.sqrt(sum_B_component)*10**(6)
    return B_effective

def main_single(args):
    """
    Docstring needed
    """
    B_phasors_1 = calc_B_phasors(args.I, args.xp, args.yp, args.ph_1_deg, args.x1, args.y1)
    B_phasors_2 = calc_B_phasors(args.I, args.xp, args.yp, args.ph_2_deg, args.x2, args.y2)
    B_phasors_3 = calc_B_phasors(args.I, args.xp, args.yp, args.ph_3_deg, args.x3, args.y3)
    
    B_eff = calc_B_effective(B_phasors_1, B_phasors_2, B_phasors_3)
    
    print('In point of coordinates (', args.xp, ',', args.yp, '), the magnetic induction is ', round(B_eff,2), ' microTesla.')


def main_double(args):
    """
    Docstring needed
    """
    B_phasors_1_A = calc_B_phasors(args.A_I, args.xp, args.yp, args.A_ph_1_deg, args.A_x1, args.A_y1)
    B_phasors_2_A = calc_B_phasors(args.A_I, args.xp, args.yp, args.A_ph_2_deg, args.A_x2, args.A_y2)
    B_phasors_3_A = calc_B_phasors(args.A_I, args.xp, args.yp, args.A_ph_3_deg, args.A_x3, args.A_y3)

    B_phasors_1_B = calc_B_phasors(args.B_I, args.xp, args.yp, args.B_ph_1_deg, args.B_x1, args.B_y1)
    B_phasors_2_B = calc_B_phasors(args.B_I, args.xp, args.yp, args.B_ph_2_deg, args.B_x2, args.B_y2)
    B_phasors_3_B = calc_B_phasors(args.B_I, args.xp, args.yp, args.B_ph_3_deg, args.B_x3, args.B_y3)

    B_eff = calc_B_effective(B_phasors_1_A, B_phasors_2_A, B_phasors_3_A, B_phasors_1_B, B_phasors_2_B, B_phasors_3_B)

    print('In point of coordinates (', args.xp, ',', args.yp, '), the magnetic induction is ', round(B_eff,2), ' microTesla.')