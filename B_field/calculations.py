from cmath import rect
from math import radians

import numpy as np
from numpy.core.fromnumeric import shape

from .config import MU_ZERO, PI


def _which_iterator(subparser_type):
    '''
    Based on the subparser type, it returns the corresponding iterator useful in "for" loops in the calculation and graphical part.

    Parameters
    -------------------
    subparser_type : str
        Parsed argument, indicating the subparser called in the command line.

    Returns
    -------------------
    iter_triad : int
        Iterator useful in "for" loops.
    '''
    if subparser_type == 'single':
        iter_triad = 1
    elif subparser_type == 'double':
        iter_triad = 2
    return iter_triad


def calc_B_phasors(current, xp, yp, cable_array):

    """It calculates the phasors of the x and y components of the
    magnetic induction field B in a given point for a given cable.

    Given the input, the function rectifies the current phase
    extracting respectively the real and imaginary part of it.
    Then, both real and imaginary part of x and y components are
    multiplied by a transfer function (dependent on the spatial
    disposition of the cable in respect to the point of interest)
    resulting in the magnetic inductin B phasor components of a
    single cable.

    Parameters
    -------------------
    current : int
        Current (A) circulating inside the considered power line
        (composed of a triad of cables)
    xp, yp : float
        Abscissa (m) and ordinate (m) of the point of interest where
        the magnetic induction field B will be calculated at last
    cable_array : numpy.ndarray
        First column - Current phase belonging to the n-th cable under consideration
        Second and third columns - Abscissa and ordinate of the n-th cable under consideration

    Returns
    -------------------
    B_phasors_n : numpy.ndarray
        Respectively the real and imaginary part (columns) of the
        x and y components (rows) of the magnetic induction field B
        produced by a single cable in a given point

    Notes
    -------------------
    The current function implements the calculations present both in
    [1]_"Norma Italiana CEI 106-11" formulas (5) and [2]_"Norma Italiana
    CEI 211-4" formulas (16).

    References
    -------------------
    ..[1] Norma Italiana CEI 106-11, "Guide for the determination of
    the respect widths for power lines and substations according to
    DPCM 8 July 2003 (Clause 6) - Part 1: Overhead lines and cables",
    first edition, 2006-02.
    ..[2] Norma Italiana CEI 211-4, "Guide to calculation methods of
    electric and magnetic fields generated by power-lines and electrical
    substations", second edition, 2008-09.
    """

    ph_n_rad = radians(cable_array[0])
    I_complex = rect(current, ph_n_rad)
    I_components = np.array([I_complex.real, I_complex.imag])
    coef = (MU_ZERO / (2*PI)) / ((xp - cable_array[1])**2 + (yp - cable_array[2])**2)
    transfer_fn_n = np.array([(cable_array[2] - yp) * coef, (xp - cable_array[1]) * coef]).reshape(2, 1)
    B_phasors_n = I_components * transfer_fn_n
    return B_phasors_n


def calc_B_effective(*B_phasors):

    """It calculates the effective value of the magnetic induction field B
    (microTesla) in a given point, considering the magnetic induction of
    all the cables provided.

    Firstly, the function computes the resulting real and imaginary parts
    of the x and y magnetic induction field components considering all the
    contributing cables given as input (typically three or six cables).
    The 'B_components' 2x2 numpy matrix indicates this intermediate step.

    Secondly, the module of the effective magnetic induction field B is
    calculated as the squared root of the sum of the squares of the
    components mentioned above.

    Lastly, the result is transformed from Tesla units to micro Tesla units.

    Parameters
    -------------------
    *B_phasors : numpy.ndarray
        Respectively the real and imaginary part (columns) of the
        x and y components (rows) of the magnetic induction field B
        produced by a single cable in a given point

    Returns
    -------------------
    B_effective_microT : float
        Effective magnetic induction field B (microTesla) calculated in the given point

    Notes
    -------------------
    The current function implements the calculations present both in
    [1]_"Norma Italiana CEI 106-11" formulas (3-4) and [2]_"Norma Italiana
    CEI 211-4" formulas (17).

    References
    -------------------
    ..[1] Norma Italiana CEI 106-11, "Guide for the determination of
    the respect widths for power lines and substations according to
    DPCM 8 July 2003 (Clause 6) - Part 1: Overhead lines and cables",
    first edition, 2006-02.
    ..[2] Norma Italiana CEI 211-4, "Guide to calculation methods of
    electric and magnetic fields generated by power-lines and electrical
    substations", second edition, 2008-09.
    """
    B_components = 0
    for B_phasor in B_phasors:
        B_components += B_phasor
    B_effective_T = np.sqrt(np.sum(B_components**2))
    B_effective_microT = B_effective_T*10**(6)
    return B_effective_microT


def main_point(current_s, xp, yp, diam_cables, cables_array, subparser_type):
    """Given one or two triads of cables (i.e. power lines), the function
    computes the composed effective magnetic induction B in a given point.

    The respective phasors of the magnetic induction B of each cable
    are iteratively computed and then composed to obtain the result.

    N.B. - In case the point of interest is too close to one of the cables,
    i.e. inside the 2D space effectively occupied by the cables,
    a dummy B value of 9999 microTesla is returned.
    This is done in order to not nullify the denominator.

    Parameters
    -------------------
    current_s : numpy.ndarray
        Current (A) circulating inside the considered power line/lines
        (each one composed of a triad of cables)
    xp, yp : float
        Abscissa (m) and ordinate (m) of the point of interest where
        the magnetic induction field B will be calculated at last
    diam_cables : float
        Diameter (m) of the cables in use
    cable_array : numpy array
        First column - Current phase belonging to the n-th cable under consideration
        Second and third columns - Abscissa and ordinate of the n-th cable under consideration

    Returns
    -------------------
    B_eff : float
        Effective magnetic induction field B (microTesla) calculated in the given point
    """
    point_P = np.array((xp, yp))
    radius_cable = diam_cables/2
    B_phasors_cables = np.zeros((2, 3, 2, 2))
    #2 super-sets (two triads), 3 sets (three cables each), 2 row each, 2 columns each

    iter_triad = _which_iterator(subparser_type)
    for j in range(iter_triad):
        for i in range(3):
            if np.sum(np.square(point_P - np.array((cables_array[j, i, 1], cables_array[j, i, 2])))) < radius_cable:
                B_dummy = 9999
                return B_dummy
            B_phasors_cables[j, i,] = calc_B_phasors(current_s[j], xp, yp, cables_array[j, i,])
    B_eff = calc_B_effective(B_phasors_cables[0, 0, ], B_phasors_cables[0, 1, ], B_phasors_cables[0, 2, ],
                             B_phasors_cables[1, 0, ], B_phasors_cables[1, 1, ], B_phasors_cables[1, 2, ],)
    return B_eff


def main_grid(current_s, xp, yp, diam_cables, cables_array, subparser_type):
    '''
    It calculates the B values of a 2D grid centered in the point of interest,
    with 6m side and 50cm step.

    In case a dummy B values is found, it replaces them with
    the maximum B value calculated (other than 9999 microTesla).

    Parameters
    -------------------
    current_s : numpy.ndarray
        Current (A) circulating inside the considered power line/lines
        (each one composed of a triad of cables)
    xp, yp : float
        Abscissa (m) and ordinate (m) of the point of interest where
        the magnetic induction field B will be calculated at last
    diam_cables : float
        Diameter (m) of the cables in use
    cable_array : numpy array
        First column - Current phase belonging to the n-th cable under consideration
        Second and third columns - Abscissa and ordinate of the n-th cable under consideration
    subparser_type : str
        Parsed argument, indicating the subparser called in the command line.

    Returns
    -------------------
    x, y, z_grid : numpy.ndarray
        (1D) Abscissas (m) and ordinates (m) having the point of interest in their center.
        (2D) B values corresponding to the (x,y) couples.
    '''
    nx, ny = 13, 13
    x = np.linspace(xp-3, xp+3, nx)
    y = np.linspace(yp-3, yp+3, ny)
    z_grid = np.zeros((ny, nx))
    X, Y = np.meshgrid(x, y, sparse=True, indexing='xy')
    #cartesian indexing: treat X[j, i] Y[j, i]

    for i in range(nx):
        for j in range(ny):
            z_grid[j, i] = main_point(current_s, X[0, i], Y[j, 0], diam_cables, cables_array, subparser_type)

    index_dummy = np.where(z_grid == 9999)
    z_grid[index_dummy] = np.unique(z_grid)[-2]
    return x, y, z_grid


def centroid(cables_array, subparser_type):
    '''
    It calculates the abscissa (m) and ordinate (m) of the cables' center of gravity.

    Parameters
    -------------------
    cable_array : numpy array
        First column - Current phase belonging to the n-th cable under consideration
        Second and third columns - Abscissa and ordinate of the n-th cable under consideration
    subparser_type : str
        Parsed argument, indicating the subparser called in the command line.

    Returns
    -------------------
    xg, yg : float
        Abscissa (m) and ordinate (m) of the cables' center of gravity
    '''
    num_cables = 3
    iter_triad = _which_iterator(subparser_type)
    coord_sum = np.nansum(np.sum(cables_array, axis=1), axis=0)
    x_sum, y_sum = coord_sum[1], coord_sum[2]
    xg, yg = x_sum/(num_cables*iter_triad), y_sum/(num_cables*iter_triad)
    return xg, yg


def is_underground(cables_array, subparser_type):
    '''
    It checks if the cables' configuration is underground, that is: the cables are extremely close to each other (i.e. 0.5 meters)
    In case, sets the parameters of the space subdivision operated through the "linspace" function.

    Parameters
    -------------------
    cable_array : numpy array
        First column - Current phase belonging to the n-th cable under consideration
        Second and third columns - Abscissa and ordinate of the n-th cable under consideration
    subparser_type : str
        Parsed argument, indicating the subparser called in the command line.

    Returns
    -------------------
    delta, nx : int
        The unilateral distance (m) that will be used along x and y axis to investigate the surrounding of the point of interest.
        Number of intervals into which the bilateral distances to investigate (having xp, yp as the middle point) will be divided.

    Notes
    -------------------
    To check if the cables are underground the relative distance is used, instead of just checking the ordinates (that should be negative).
    This is because, hypothetically, the reference system origin could be put anywhere.
    For convenience, the documentation strongly recommends where to place this origin.
    '''

    iter_triad = _which_iterator(subparser_type)
    num_cables = 3

    for j in range(iter_triad):
        for i in range(num_cables):
            if np.linalg.norm(np.array((cables_array[j, i-1, 1], cables_array[j, i-1, 2]))-np.array((cables_array[j, i, 1], cables_array[j, i, 2]))) < 0.5:
                delta, nx = 6, 121
            else:
                delta, nx = 35, 71
    return delta, nx


def lim_val_checker(xg, x, nx, z_array, lim_val):
    '''
    It checks on both sides of the trellis at which abscissa (m) the given limit value (microTesla) is exceeded.
    The ordinate (m) at which the computation is done is fixed and it corresponds to yg, the cables' center of gravity.

    Parameters
    -------------------
    xg : float
        Abscissa (m) of the cables' center of gravity
    x, z_array : numpy.ndarray
        (1D) Abscissas (m) having the cables' center of gravity xg in their center and (1D) B values corresponding to the (x,yg) couples
    nx : int
        Number of intervals into which the bilateral distances to investigate (having xg, yg as the middle point) will be divided
    lim_val : list of float
        MicroTesla value at which is estimated the DPA (distanza di prima approssimazione)

    Returns
    -------------------
    dpa_value : float
        Value of the estimated DPA (distanza di prima approssimazione) at the given limit value
    '''

    dpa_left_right = np.zeros(2)
    for i in range(nx-1):
        if z_array[i] <= lim_val < z_array[i+1]:
            dpa_left_right[0] = xg-x[i]
        if z_array[i] > lim_val >= z_array[i+1]:
            dpa_left_right[1] = x[i+1]-xg
    dpa_value = np.max(dpa_left_right)
    return dpa_value


def main_dpa(current_s, diam_cables, cables_array, subparser_type, lim_val):
    '''
    It calculates the DPA (distanza di prima approssimazione - meters) at the given limit value (microTesla).
    A single value is provided, meaning a symmetrical DPA with respect to the cables' center of gravity abscissa xg.

    Parameters
    -------------------
    current_s : numpy.ndarray
        Current (A) circulating inside the considered power line/lines
        (each one composed of a triad of cables)
    diam_cables : float
        Diameter (m) of the cables in use
    cable_array : numpy array
        First column - Current phase belonging to the n-th cable under consideration
        Second and third columns - Abscissa and ordinate of the n-th cable under consideration
    subparser_type : str
        Parsed argument, indicating the subparser called in the command line.
    lim_val : list of float
        MicroTesla value at which is estimated the DPA (distanza di prima approssimazione)

    Returns
    -------------------
    dpa_value : float
        Value of the estimated DPA (distanza di prima approssimazione) at the given limit value
    '''
    xg, yg = centroid(cables_array, subparser_type)
    delta, nx = is_underground(cables_array, subparser_type)

    x = np.linspace(xg-delta, xg+delta, nx)
    y = yg
    z_array = np.zeros(nx)
    for i in range(nx):
        z_array[i] = main_point(current_s, x[i], y, diam_cables, cables_array, subparser_type)

    dpa_value = lim_val_checker(xg, x, nx, z_array, lim_val)
    return dpa_value


def main_print_point_bidim_dpa(current_s, xp, yp, diam_cables, cables_array, args, file=None):
    '''
    Utility function that groups the calls to 'point', 'bidim' and 'dpa' CL optional arguments and prints the respective output.

    Print's 'file' keyword argument is made explicit so that it can be replaced with the selected destination file
    in case the "save" CL optional argument is invoked.

    Parameters
    -------------------
    current_s : numpy.ndarray
        Current (A) circulating inside the considered power line/lines
        (each one composed of a triad of cables)
    xp, yp : float
        Abscissa (m) and ordinate (m) of the point of interest where
        the magnetic induction field B will be calculated at last
    diam_cables : float
        Diameter (m) of the cables in use
    cable_array : numpy array
        First column - Current phase belonging to the n-th cable under consideration
        Second and third columns - Abscissa and ordinate of the n-th cable under consideration
    args : argparse.Namespace
        Namespace object build up from attributes parsed out of the command line
    file : opened file, default=None
        Destination file of all the print statements

    Returns
    -------------------
    None
    '''

    if args.point:
        B_point = main_point(current_s, xp, yp, diam_cables, cables_array, args.subparser)
        print('\nIn point of coordinates (', xp, ',', yp, '), the magnetic induction is ', round(B_point, 2), ' microTesla.\n', file=file)

    if args.bidim:
        B_grid = main_grid(current_s, xp, yp, diam_cables, cables_array, args.subparser)
        print('''\n------Grid of B field values (microTesla)------\n----Point of interest in the matrix center-----\n\n''', np.flipud(B_grid[2]), file=file)
        # with the flip up down you see the matrix as if it was a xy grid

    if args.dpa:
        dpa_value = main_dpa(current_s, diam_cables, cables_array, args.subparser, args.dpa)
        print('\nThe value of the DPA (Distanza di Prima Approssimazione) is ', round(dpa_value, 1), ' meters from the cables\' center of gravity abscissa.\n', file=file)
